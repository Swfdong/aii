package aii.ui.managers {	import aii.ui.graphics.*;	import aii.ui.graphics.border.*;	import aii.ui.styles.Style;		import flash.display.Graphics;	/**	 * @author Swfdong	 */	public class GraphicManager {		//带边框的Box		public static function drawBox(target:Graphics, width:Number, height:Number, style:Style, state:uint = 0,x:Number=0,y:Number=0,needfill:Boolean=true):void {			var fill:IGraphicFill=style.getStyle("fill",state);			var border:BaseBorder=style.getStyle("border",state);			if(needfill){				border.draw(target,width,height,fill,x,y);			}else{				border.draw(target,width,height,null,x,y);			}		}		/**		 * 绘制圆角矩形（来自mx.utils.GraphicUtil类中的drawRoundRectComplex方法）。		 * @param target 指示用于绘制圆角矩形的Graphic对象。		 * @param x 圆角矩形的横坐标。		 * @param y 圆角矩形的纵坐标。		 * @param width 圆角矩形的宽度。		 * @param height 圆角矩形的高度。		 * @param topLeftRadius 左上角半径。		 * @param topRightRadius 右上角半径。		 * @param bottomLeftRadius 左下角半径。		 * @param bottomRightRadius 右下角半径。		 */		public static function drawRoundRect(target:Graphics, x:Number, y:Number, width:Number, height:Number, topLeftRadius:Number, topRightRadius:Number, bottomLeftRadius:Number, bottomRightRadius:Number):void {			var xw:Number = x + width;			var yh:Number = y + height;			// Make sure none of the radius values are greater than w/h.			// These are all inlined to avoid function calling overhead			var minSize:Number = width < height ? width / 2 : height / 2;			topLeftRadius = topLeftRadius < minSize ? topLeftRadius : minSize;			topRightRadius = topRightRadius < minSize ? topRightRadius : minSize;			bottomLeftRadius = bottomLeftRadius < minSize ? bottomLeftRadius : minSize;			bottomRightRadius = bottomRightRadius < minSize ? bottomRightRadius : minSize;			var a:Number = bottomRightRadius * 0.292893218813453; // radius - anchor pt;			var s:Number = bottomRightRadius * 0.585786437626905; // radius - control pt;			target.moveTo(xw, yh - bottomRightRadius);			target.curveTo(xw, yh - s, xw - a, yh - a);			target.curveTo(xw - s, yh, xw - bottomRightRadius, yh);			// bottom-left corner			a = bottomLeftRadius * 0.292893218813453;			s = bottomLeftRadius * 0.585786437626905;			target.lineTo(x + bottomLeftRadius, yh);			target.curveTo(x + s, yh, x + a, yh - a);			target.curveTo(x, yh - s, x, yh - bottomLeftRadius);			// top-left corner			a = topLeftRadius * 0.292893218813453;			s = topLeftRadius * 0.585786437626905;			target.lineTo(x, y + topLeftRadius);			target.curveTo(x, y + s, x + a, y + a);			target.curveTo(x + s, y, x + topLeftRadius, y);			// top-right corner			a = topRightRadius * 0.292893218813453;			s = topRightRadius * 0.585786437626905;			target.lineTo(xw - topRightRadius, y);			//if(topRightRadius>0){				target.curveTo(xw - s, y, xw - a, y + a);				target.curveTo(xw, y + s, xw, y + topRightRadius);			//}			target.lineTo(xw, yh - bottomRightRadius);		}	}}