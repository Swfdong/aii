/* license section

   Aii is free software: you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation, either version 3 of the License, or   (at your option) any later version.   Aii is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.   You should have received a copy of the GNU General Public License   along with Aii.  If not, see <http://www.gnu.org/licenses/>.   © Swfdong 2010 */ //用户列表数据,考虑到效率原因Dictionary使用publicpackage aii.net.xiaonei {	import flash.events.EventDispatcher;	import flash.utils.Dictionary;	import aii.net.ResourceAccess;	import aii.net.events.RosterEvent;	import aii.utils.TaskMonitor;	import aii.utils.Logger;
	public final class XNRoster extends EventDispatcher {		protected namespace XMPP_ROSTER = "jabber:iq:roster"		protected namespace XMPP_VCARD = "vcard-temp"		protected namespace XMPP_C = "http://jabber.org/protocol/caps"		protected namespace XMPP_X = "vcard-temp:x:update"		protected static const QNick:QName = new QName("http://jabber.org/protocol/nick", "nick");		private static const QXNStatus:QName = new QName("xn:talk:vcard", "STATUS");		public var dataByJID:Dictionary;		public var dataByGroup:Dictionary;		public var groups:Array;		////////////////////////////////////		private static const STATUS_DICT:Dictionary = new Dictionary();		////////////////////////////////////		private var _friendsCount:uint = 0;		private var _onlineCount:uint = 0;		private var _groupsCount:uint = 0;		private var data:Vector.<XNCard>;		private var _selfCard:XNCard;		private var tm:TaskMonitor;		private var tmpList:Object;		private var i:int;		private var g:Dictionary;		private var tmpCard:XNCard;		private var init:Boolean = false;		private var pendingData:Array;		private var cache:Array;
		public function XNRoster():void {			tm = new TaskMonitor();			dataByJID = new Dictionary();			dataByGroup = new Dictionary();			data = new Vector.<XNCard>;			groups = new Array();			g = new Dictionary();			STATUS_DICT[""] = "客户端在线";			STATUS_DICT["away"] = "离开";			STATUS_DICT["dnd"] = "忙碌";			STATUS_DICT["web"] = "网页在线";			pendingData = new Array();		}
		public function set selfID(s:String):void {			if (_selfCard == null) {				_selfCard = new XNCard(s);			} else {				_selfCard.id = s;			}			cache = ResourceAccess.getObj("XNRoster-" + _selfCard.id) as Array;		}
		public function save():void {			var sv:Array = new Array();			sv.push(_selfCard.id);			for (var j:uint = 0; j < _friendsCount; j++) {				sv.push([ data[j].id, data[j].status, data[j].richStatus, data[j].info, data[j].update ]);			}			ResourceAccess.saveObj("XNRoster-" + _selfCard.id, sv);		}
		public function updateFromIQ(xmlData:XML):void {			use namespace XMPP_VCARD;			var tcard:XNCard;			var e:RosterEvent;			var id:String = xmlData.@from;			var l:int = id.indexOf("/");			id = (l != -1 ? id.slice(0, l) : id);			if (id == _selfCard.id) {				tcard = _selfCard;				e = new RosterEvent(RosterEvent.SELF_VCARD);			} else if (dataByJID[id]) {				tcard = dataByJID[id];				e = new RosterEvent(RosterEvent.FRIEND_VCARD);			}			tcard.nick = xmlData.vCard.FN;			tcard.jid = xmlData.@from;			tcard.headUrl = xmlData.vCard.PHOTO.EXTVAL;			tcard.status = xmlData.vCard.elements(QXNStatus);			tcard.richStatus = xmlData.richstatus;			tcard.update = new Date().getTime();			dispatchEvent(e);		}
		public function updateFromPresence(xmlData:XML):void {			if (init) {				if (xmlData != null) {					var tid:String = getID(xmlData.@from);					if (dataByJID[tid] != undefined) {						var tcard:XNCard = dataByJID[tid];						var j:uint;						var k:uint = tcard.groups.length;						if (xmlData.@type != "unavailable") {							if (!tcard.online) {								tcard.online = true;								for (j = 0; j < k; j++) {									groups[g[tcard.groups[j]]].online++;								}								_onlineCount++;							}							if (xmlData.hasOwnProperty("show")) {								tcard.onlineStatus = xmlData.show;							} else {								tcard.onlineStatus = "";							}							tcard.status = xmlData.status;							tcard.richStatus = xmlData.richstatus;							if (xmlData.elements(QNick)[0] != undefined) {								tcard.nick = xmlData.elements(QNick)[0];							}							use namespace XMPP_X;							tcard.headUrl = xmlData.x.PHOTO.EXTVAL;							use namespace XMPP_C;							tcard.onlineStatus = ((xmlData.c.@ver == "webpager") ? "web" : tcard.onlineStatus);							Logger.log("[XNRoster]" + tcard.nick + " 的在线状态更改为 " + STATUS_DICT[tcard.onlineStatus] + "(" + (xmlData.c.@ver) + ")");						} else {							if (tcard.online) {								tcard.onlineStatus = "";								tcard.online = false;								for (j = 0; j < k; j++) {									groups[g[tcard.groups[j]]].online--;								}								_onlineCount--;							}							Logger.log("[XNRoster]" + tcard.nick + "的在线状态更改为 离线");						}						for (j = 0; j < k; j++) {							dataByGroup[tcard.groups[j]].sortOn([ "online", "onlineStatus", "nick" ], [ Array.DESCENDING, null, null ]);						}						var e:RosterEvent = new RosterEvent(RosterEvent.ONLINE_CHANGE);						tcard.update = new Date().getTime();						e.data = tcard;						dispatchEvent(e);					}				}			} else {				pendingData.push(xmlData);			}		}
		public function initFriends(objData:Object):void {			Logger.start();			_friendsCount = objData.list.length;			var e:RosterEvent = new RosterEvent(RosterEvent.ONLINE_CHANGE);			dispatchEvent(e);			tmpList = objData;			i = 0;			tm.run(initFriendsLoop, initFriendsEnd);		}
		public function initFriendsLoop():void {			var k:uint;			while (tm.condition(i < _friendsCount)) {				tmpCard = new XNCard(String(tmpList.list[i].id), tmpList.list[i].name, tmpList.list[i].groups);				data.push(tmpCard);				tmpCard.vip = tmpList.list[i].vip;				tmpCard.star = tmpList.list[i].selected;				tmpCard.mobile = tmpList.list[i].mo;				tmpCard.tinyUrl = tmpList.list[i].head;				tmpCard.online = tmpList.list[i].isOnline;				if (tmpList.list[i].isOnline) {					tmpCard.onlineStatus = "unknown";				}				if (tmpCard.groups[0] == undefined) {					tmpCard.groups[0] = "未分组";				}				dataByJID[tmpCard.id] = tmpCard;				k = tmpList.list[i].groups.length;				for (var j:uint = 0; j < k; j++) {					if (dataByGroup[tmpCard.groups[j]] != undefined) {						dataByGroup[tmpCard.groups[j]].push(tmpCard);					} else {						_groupsCount++;						dataByGroup[tmpCard.groups[j]] = new Array();						dataByGroup[tmpCard.groups[j]].push(tmpCard);						groups.push({ label: tmpCard.groups[j], data: dataByGroup[tmpCard.groups[j]], online: 0 });					}				}				i++;			}		}
		public function initFriendsEnd():void {			groups.sortOn([ "label" ]);			for (var i:uint = 0; i < _groupsCount; i++) {				g[groups[i].label] = i;			}			tmpList = null;			if (cache != null && cache[0] == _selfCard.id) {				cache.shift();				var k:uint = cache.length;				for (var j:uint = 0; j < k; j++) {					if (dataByJID[cache[j][0]] != undefined) {						var tc:XNCard = dataByJID[cache[j][0]];						tc.status = cache[j][1];						tc.richStatus = cache[j][2];						tc.info = cache[j][3];						tc.update = cache[j][4];					}				}			}			Logger.end("[XNRoster]初始化好友列表完毕");			init = true;			var e:RosterEvent = new RosterEvent(RosterEvent.INIT);			dispatchEvent(e);			i = pendingData.length;			tm.run(updatePendingFriends, updatePendingFriendsEnd);		}
		//初始化在线好友(为避免200个以上好友在线时卡的现象,使用TaskMonitor进行处理		public function updatePendingFriends():void {			while (tm.condition(i > 0)) {				updateFromPresence(pendingData[0]);				pendingData.shift();				i--;			}		}
		public function updatePendingFriendsEnd():void {			for (var gl:String in dataByGroup) {				dataByGroup[gl].sortOn([ "online", "onlineStatus", "nick" ], [ Array.DESCENDING, null, null ]);			}			var e:RosterEvent = new RosterEvent(RosterEvent.ONLINE_INIT);			dispatchEvent(e);		}
		public function get self():XNCard {			return _selfCard;		}
		public function get totalCount():uint {			return _friendsCount;		}
		public function get onlineCount():uint {			return _onlineCount;		}
		public function get groupsCount():uint {			return _groupsCount;		}
		private static function getID(j:String):String {			return j.slice(0, j.lastIndexOf("/"));		}	}}