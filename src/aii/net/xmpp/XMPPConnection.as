package aii.net.xmpp {	import aii.net.events.XMPPEvent;	import aii.net.utils.Base64;	import aii.utils.Logger;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.events.StatusEvent;	import flash.events.TimerEvent;	import flash.net.Socket;	import flash.system.System;	import flash.utils.ByteArray;	import flash.utils.Dictionary;	import flash.utils.Timer;	import flash.utils.getTimer;	/**	 * 经过优化的XMPP连接	 * 修改自XIFF	 * @author Swfdong	 */	public final class XMPPConnection extends EventDispatcher {		private static const FLOOD_TAG_COUNT:uint = 3;		private static const FLOOD_TAG_START:Vector.<String>  = Vector.<String>([ "<iq", "<presence", "<message" ]);		private static const FLOOD_TAG_END:Vector.<String>  = Vector.<String>([ "</iq>", "</presence>", "</message>" ]);		//Getter&Setter私有属性		private var _host:String;		private var _port:int;		private var _userid:String;		private var _password:String;		private var _timeout:Number;		private var _resource:String;		private var _loggedIn:Boolean;		private var _active:Boolean;		private var _jid:JID;		private var _ticket:String;		private var _authSuccess:Boolean;		//私有属性		private var socket:Socket;		private var iqcount:int = 0;		private var incomRawBytes:ByteArray;		private var prevSendObj:Object;		private var stanzaCallbackQueue:Dictionary;		private var systemCallbackQueue:Dictionary;		private var sendTimer:Timer;		private var timeoutCount:uint;		//IQ队列		private var pendingIQ:Array;		//常用TAG		private var openingTag:String;		private const closingTag:String = "</stream:stream>";		/**		 * 创建新的 XMPP连接 对象。		 * @param host 目标主机的完全限定的 DNS 域名或 IP 地址。		 * @param port  用于建立连接的目标主机上的 TCP 端口号。		 * @default port 5222		 * @param resource 资源名。		 * @default resource AII-XMPP		 * @param timeout 连接超时限制，单位为毫秒。		 * @default timeout 1000		 */		public function XMPPConnection(host:String, port:int = 5222, resource:String = "AII-XMPP", timeout:int = 1000):void {			_host = host;			_port = port;			_resource = resource;			_timeout = timeout;			_loggedIn = false;			_active = false;			XML.prettyPrinting = false;			XML.ignoreWhitespace = true;			socket = new Socket();			openingTag = "<stream:stream to='" + _host + "' xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'>";			sendTimer = new Timer(4000, 1);		}		/**		 * 登录到目标主机。		 * @param uid 用于登录的用户名		 * @param pwd 用于登录的密码		 */		public function login(uid:String, pwd:String):void {			_loggedIn = false;			_active = false;			_userid = uid;			_password = pwd;			_jid = new JID(_userid + "@" + _host + "/" + _resource);		}		/**		 * 关闭与目标主机的连接。		 */		public function disconnect():void {			if (_active) {				sendXML(closingTag);			}			sendTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, timeoutHandler);			sendTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, connectTimeout);			socket.close();			_loggedIn = false;			_active = false;		}		/**		 * 发送数据到目标主机。		 * @param obj 需要发送到目标主机的数据。		 */		public function send(obj:IXMPPStanza):void {			var needRespond:Boolean = false;			if (obj.callBack != null) {				stanzaCallbackQueue[obj.id] = obj.callBack;				needRespond = true;			}			if (obj is IQ) {				if (iqcount < 9) {					iqcount++;				} else {					pendingIQ.push(obj);					return;				}			}			sendXML(obj.xml, needRespond);		}		/**		 * 发送XML数据到目标主机。		 * @param obj  需要发送的XML对象。		 * @param needRespond 指示该条请求是否需要回应。		 */		public function sendXML(obj:*, needRespond:Boolean = true):void {			socket.writeUTFBytes(obj);			socket.flush();			//Logger.log("[XMPP]发送: "+obj);			if (needRespond) {				if (obj != " ") {					prevSendObj = obj;				}				sendTimer.start();			}			//出于轻量化要求,此处不广播事件		}		protected function keepAlive():void {			sendXML(" ");		}		//////////////////////////侦听//////////////////////////		//测试连接		private function connectStatus(e:StatusEvent):void {			Logger.log("[XMPP]远端服务可用,正在连接...");			incomRawBytes = new ByteArray();			socket.addEventListener(Event.CONNECT, connectedHandler);			socket.addEventListener(Event.CLOSE, closedHandler);			socket.addEventListener(ProgressEvent.SOCKET_DATA, dataHandler);			socket.addEventListener(IOErrorEvent.IO_ERROR, IOErrorHandler);			//socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR,securityErrorHandler);			socket.connect(_host, _port);			sendTimer.delay = 4000;			sendTimer.addEventListener(TimerEvent.TIMER_COMPLETE, connectTimeout);			sendTimer.start();			_timeout = getTimer();		}		//连接超时		private function connectTimeout(e:TimerEvent):void {			//如果超时小于3次			disconnect();			if (timeoutCount < 3) {				timeoutCount++;				login(_userid, _password);			} else {				Logger.error("[XMPP]连接失败!");				timeoutCount = 0;			}		}		//出错		private function IOErrorHandler(e:IOErrorEvent):void {			Logger.error("[XMPP]发生IO错误!");			var xe:XMPPEvent = new XMPPEvent(XMPPEvent.ERROR);			xe.data = "[XMPP]发生未知错误！";			dispatchEvent(xe);		}		//连接		private function connectedHandler(e:Event):void {			Logger.log("[XMPP]连接开启，主机:" + _host + "，端口:" + _port);			_active = true;			_authSuccess = false;			stanzaCallbackQueue = new Dictionary();			systemCallbackQueue = new Dictionary();			pendingIQ = new Array();			systemCallbackQueue["stream"] = handleStream;			socket.removeEventListener(Event.CONNECT, connectedHandler);			sendXML(openingTag);		}		//连接关闭		private function closedHandler(e:Event):void {			socket.removeEventListener(Event.CONNECT, connectedHandler);			socket.removeEventListener(Event.CLOSE, closedHandler);			socket.removeEventListener(ProgressEvent.SOCKET_DATA, dataHandler);			sendTimer.reset();			var xe:XMPPEvent = new XMPPEvent(XMPPEvent.CLOSED);			dispatchEvent(xe);		}		//连接超时		private function timeoutHandler(e:Event):void {			sendTimer.reset();			//如果超时小于10次;			if (prevSendObj != null) {				if (timeoutCount < 10) {					timeoutCount++;					keepAlive();					if (timeoutCount == 5) {						Logger.warn("[XMPP]已重试5次");					}				} else {					Logger.warn("[XMPP]10次未回应，将重新发送");					timeoutCount = 0;					sendXML(prevSendObj);				}			}		}		//接收数据		private function dataHandler(e:ProgressEvent):void {			System.gc();			timeoutCount = 0;			sendTimer.reset();			socket.readBytes(incomRawBytes, incomRawBytes.length);			incomRawBytes.position = 0;			var rawXML:String = incomRawBytes.readMultiByte(incomRawBytes.bytesAvailable, "UTF-8");			var XMLData:XMLList;			//预处理			if (rawXML.indexOf("<stream:stream") > -1) {				rawXML = rawXML.concat("</stream:stream>");			}			if (rawXML.indexOf("<stream:features") > -1) {				rawXML = rawXML.replace(/stream:features/g, "features");			}			var isComplete:Boolean = false;			try {				XMLData = XMLList(rawXML);				incomRawBytes.clear();				isComplete = true;			} catch (err:Error) {				//未完成有两种可能				//trace(rawXML/*prevRawBytes.length+"\n"+rawXML.slice(rawXML.length-20)*/);				for (var i:uint = 0; i < FLOOD_TAG_COUNT; i++) {					//上线时涌入的数据,进行分批处理					var startPosition:int = rawXML.indexOf(FLOOD_TAG_START[i]);					var endPosition:int = rawXML.lastIndexOf(FLOOD_TAG_END[i]);					if (startPosition != -1 && endPosition != -1) {						isComplete = true;						var cutPosition:int = endPosition + FLOOD_TAG_END[i].length;						XMLData = XMLList(rawXML.substring(startPosition, cutPosition));						incomRawBytes.clear();						incomRawBytes.writeMultiByte(rawXML.substr(cutPosition), "UTF-8");						break;					}				}				keepAlive();			}			if (isComplete) {				prevSendObj = null;				var XMLItem:XML;				for each (XMLItem in XMLData) {					var nodeName:String = XMLItem.name().localName.toLowerCase();					//去掉switch case改用回调队列					if (systemCallbackQueue[nodeName] is Function) {						systemCallbackQueue[nodeName](XMLItem);							//Logger.log("[XMPP]收到标签:"+nodeName);					} else {						//Logger.warn("[XMPP]收到未设定回调的标签:"+nodeName);					}				}			} else {				Logger.log("[XMPP]收到未完成数据，已积累" + (incomRawBytes.length >> 10) + "KB");			}			System.gc();		}		/////////////////////不同数据处理//////////////////////////		//创建新流		private function handleStream(XMLItem:XML):void {			sendTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, connectTimeout);			if (!sendTimer.hasEventListener(TimerEvent.TIMER_COMPLETE)) {				sendTimer.delay = _timeout;				sendTimer.addEventListener(TimerEvent.TIMER_COMPLETE, timeoutHandler);			}			systemCallbackQueue["features"] = handleFeatures;			if (XMLItem.children() != undefined && XMLItem.children()[0].localName() == "features") {				handleFeatures(XMLItem.children()[0]);			} else {				keepAlive();			}		}		//登录继续		private function handleFeatures(XMLItem:XML):void {			var qn:QName = new QName("urn:ietf:params:xml:ns:xmpp-sasl", "mechanisms");			if (XMLItem.elements(qn).children()[0] == "PLAIN") {				var authCode:String = Base64.encode(_jid.id + '\u0000' + _jid.uid + '\u0000' + _password);				systemCallbackQueue["success"] = handleSuccess;				systemCallbackQueue["failure"] = handleFailure;				sendXML("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' xmlns:ga='http://www.google.com/talk/protocol/auth' ga:client-uses-full-bind-result='true' mechanism='PLAIN'>" + authCode + "</auth>");			} else {				delete systemCallbackQueue["features"];				systemCallbackQueue["iq"] = handleIQ;				var e:XMPPEvent = new XMPPEvent(XMPPEvent.FEATURE);				dispatchEvent(e);			}		}		//验证成功(为加快登录速度此处直接发送字符串而非使用自定义类型)		private function handleSuccess(XMLItem:XML):void {			_authSuccess = true;			var e:XMPPEvent = new XMPPEvent(XMPPEvent.SUCCESS);			dispatchEvent(e);			delete systemCallbackQueue["success"];			delete systemCallbackQueue["failure"];			sendXML(openingTag);		}		//验证失败		private function handleFailure(XMLItem:XML):void {			delete systemCallbackQueue["success"];			delete systemCallbackQueue["failure"];			socket.close();			var e:XMPPEvent = new XMPPEvent(XMPPEvent.FAILURE);			e.data = XMLItem;			dispatchEvent(e);		}		//IQ		private function handleIQ(XMLItem:XML):void {			var result_type:String = XMLItem.@type;			var result_id:String = XMLItem.@id;			if (result_type == IQ.RESULT) {				iqcount--;				if (pendingIQ.length > 0) {					send(pendingIQ.shift());				}				if (stanzaCallbackQueue[result_id] != undefined) {					stanzaCallbackQueue[result_id](XMLItem);					delete stanzaCallbackQueue[result_id];				} else if (systemCallbackQueue["iq-default"] != undefined) {					systemCallbackQueue["iq-default"](XMLItem);				}			}		}		/**		 * IQ标签的默认回调函数。		 * @param handler 要设定为回调的Function对象。		 */		public function set iqDefaultHandler(handler:Function):void {			systemCallbackQueue["iq-default"] = handler;		}		/**		 * Presence标签的回调函数。		 * @param handler 要设定为回调的Function对象。		 */		public function set presenceHandler(handler:Function):void {			systemCallbackQueue["presence"] = handler;		}		/**		 * Message标签的回调函数。		 * @param handler 要设定为回调的Function对象。		 */		public function set messageHandler(handler:Function):void {			systemCallbackQueue["message"] = handler;		}		/////////////////////Getter&Setter//////////////////////////		/**		 * @return 当前的资源名称。		 */		public function get resource():String {			return _resource;		}	}}