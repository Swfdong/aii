package aii.net.proxy {	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.ProgressEvent;	import flash.net.Socket;	import aii.net.events.ProxyEvent;	/**	 * HTTPProxySocket 类启用代码以建立使用HTTP代理的传输控制协议 (TCP) 套接字连接，用于发送和接收二进制数据。	 * 要使用 HTTPProxySocket 类的方法，请先使用构造函数 new HTTPProxySocket 创建一个 HTTPProxySocket 对象。	 * @author Swfdong	 */	public class HTTPProxySocket extends Socket {		private var _proxyHost:String;		private var _proxyPort:int;		private var _ua:String;		private var _host:String;		private var _port:int;		/**		 * 创建新的 HTTPProxySocket 对象。		 * @param host 代理服务器的完全限定的 DNS 域名或 IP 地址。		 * @param port 用于建立连接的代理服务器上的 TCP 端口号。		 * @default  port 80		 * @param ua 指定要在 HTTP代理 请求中使用的用户代理字符串。		 * @default ua Aii Proxy		 */		public function HTTPProxySocket(host:String, port:uint = 80, ua:String = "Aii Proxy"):void {			_proxyHost = host;			_proxyPort = port;			_ua = ua;		}		override public function connect(host:String, port:int):void {			_host = host;			_port = port;			super.connect(_proxyHost, _proxyPort);			super.addEventListener(Event.CONNECT, connectHandler, false, 0, true);		}		override public function close():void {			super.removeEventListener(Event.CONNECT, connectHandler);			super.close();		}		/**		 *  此代理套接字连接到的代理主机的地址。		 * @return		 */		public function get proxyHost():String {			return _proxyHost;		}		/**		 * 此代理套接字连接到的代理主机的端口。		 * @return		 */		public function get proxyPort():int {			return _proxyPort;		}		/**		 * 在 HTTP代理 请求中使用的用户代理字符串。		 * @return		 */		public function get userAgent():String {			return _ua;		}		/**		 *  此代理套接字连接到的远程主机的地址。		 * @return		 */		public function get host():String {			return _host;		}		/**		 * 此代理套接字连接到的远程计算机的端口。		 * @return		 */		public function get port():int {			return _port;		}		//连接侦听		private function connectHandler(e:Event):void {			super.writeUTFBytes("CONNECT " + _host + ":" + _port + " HTTP/1.0\r\nUser-Agent: " + _ua + "\r\nHost: " + _host + "\r\nContent-Length: 0\r\nProxy-Connection: Keep-Alive\r\n\r\n");			super.removeEventListener(Event.CONNECT, connectHandler);			super.addEventListener(ProgressEvent.SOCKET_DATA, proxyStateHandler, false, 0, true);			super.flush();		}		//代理状态侦听		private function proxyStateHandler(e:ProgressEvent):void {			var event:ProxyEvent;			var response:String = super.readUTFBytes(super.bytesAvailable);			super.removeEventListener(ProgressEvent.SOCKET_DATA, proxyStateHandler);			if (response.lastIndexOf("established") != -1) {				event = new ProxyEvent(ProxyEvent.CONNECTED);			} else {				event = new ProxyEvent(ProxyEvent.ERROR);			}			dispatchEvent(event);		}	}}