/* license section

   Aii is free software: you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation, either version 3 of the License, or   (at your option) any later version.   Aii is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.   You should have received a copy of the GNU General Public License   along with Aii.  If not, see <http://www.gnu.org/licenses/>.   © Swfdong 2010 */ //资源访问类,可储存/读取并缓存数据package aii.net {	import flash.display.DisplayObject;	import flash.display.Loader;	import flash.events.Event;	import flash.filesystem.*;	import flash.net.SharedObject;	import flash.net.URLRequest;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.utils.ByteArray;	import flash.utils.Dictionary;
	public class ResourceAccess {		private static const LOADER_NUM:uint = 10;		private static var _inited:Boolean = false;		private static var _userDir:File;		private static var _currentFile:File;		private static var _fileStream:FileStream;		private static var _request:URLRequest;		private static var _p:uint = 0;		private static var _loaders:Vector.<URLLoader>;		private static var _loaderFlags:Dictionary;		private static var _pendingRequests:Dictionary;		private static var _targets:Dictionary;		private static var _caches:Dictionary;
		//初始化		private static function init():void {			_userDir = File.applicationStorageDirectory;			_fileStream = new FileStream();			_request = new URLRequest();			_loaders = new Vector.<URLLoader>(LOADER_NUM, true);			_pendingRequests = new Dictionary();			_loaderFlags = new Dictionary();			_targets = new Dictionary(true);			_caches = new Dictionary();			for (var i:int = 0; i < LOADER_NUM; i += 1) {				_loaders[i] = new URLLoader();				_loaders[i].dataFormat = URLLoaderDataFormat.BINARY;				_loaderFlags[_loaders[i]] = true;				_pendingRequests[_loaders[i]] = new Array();			}			_inited = true;		}
		//储存AMF3格式数据		public static function saveObj(id:String, obj:Object):void {			if (!_inited) {				init();			}			if (obj != null) {				_currentFile = _userDir.resolvePath("data/" + id);				_fileStream.open(_currentFile, FileMode.WRITE);				_fileStream.writeObject(obj);				_fileStream.close();				_currentFile = null;			}		}
		//获取AMF3格式数据		public static function getObj(id:String):Object {			if (!_inited) {				init();			}			_currentFile = _userDir.resolvePath("data/" + id);			if (_currentFile.exists) {				_fileStream.open(_currentFile, FileMode.READ);				var res:Object = _fileStream.readObject();				_fileStream.close();				_currentFile = null;				return (res);			}			return null;		}
		//获取图像		public static function getImage(t:Loader, u:String):void {			if (!_inited) {				init();			}			if (u != null) {				if (hasCached(u)) {					var Bytes:ByteArray = new ByteArray();					_fileStream.open(_currentFile, FileMode.READ);					_fileStream.readBytes(Bytes);					_fileStream.close();					t.loadBytes(Bytes);					_currentFile = null;				} else {					if (_loaderFlags[_loaders[_p]]) {						requestImage(_loaders[_p], t, _currentFile.clone(), u);					} else {						_pendingRequests[_loaders[_p]].push({ t: t, f: _currentFile.clone(), u: u });					}					_p = _p < (LOADER_NUM - 1) ? _p + 1 : 0;				}			}		}
		private static function requestImage(l:URLLoader, t:DisplayObject, f:File, u:String):void {			_request.url = u;			_targets[l] = t;			_caches[l] = f;			_loaderFlags[l] = false;			l.addEventListener(Event.COMPLETE, loadHandler);			l.load(_request);		}
		private static function loadHandler(e:Event):void {			(_targets[e.currentTarget] as Loader).loadBytes(e.currentTarget.data as ByteArray);			_fileStream.open(_caches[e.currentTarget], FileMode.WRITE);			_fileStream.writeBytes(e.currentTarget.data as ByteArray);			_fileStream.close();			if (_pendingRequests[e.currentTarget].length > 0) {				var r:Object = _pendingRequests[e.currentTarget][0];				requestImage((e.currentTarget as URLLoader), r.t, r.f, r.u);				_pendingRequests[e.currentTarget].shift();			} else {				_loaderFlags[e.currentTarget] = true;				delete _targets[e.currentTarget];				delete _caches[e.currentTarget];				_currentFile = null;				e.currentTarget.removeEventListener(Event.COMPLETE, loadHandler);			}		}
		private static function hasCached(u:String):Boolean {			u = "cache/" + u.replace("http://", "");			_currentFile = _userDir.resolvePath(u);			if (_currentFile.exists) {				return true;			}			return false;		}	}}